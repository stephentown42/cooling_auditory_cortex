"""
Vowel In Noise Cooling - Analysis By Ferret

Plots the performance of ferrets (F1311, F1519 and F1706) discriminating vowels as a function of SNR, and across SNR during control and test conditions (cortical inactivation via cooling or light delivery / optogenetics) in clean conditions and with noise. 

Performance across SNR is shown as a scatter cloud 



Input 
-----
Data generated by bootstrap resampling.


Output
------
Separate PNG images are generated for each ferret separately.

Version History
----------------
    2021-08-??: Created (ST) and continuous updated until 2021-09
    2021-10-??: Branched for use with bootstrap data

"""

from dataclasses import dataclass
import os, sys

import matplotlib.pyplot as plt
import numpy as np
from numpy.random import PCG64
import pandas as pd
from pathlib import Path

sys.path.insert(0, os.path.abspath( os.path.join(os.path.dirname(__file__), '../..')))

from lib.colors import VOWELS_IN_NOISE as colors
from lib.metric_axes import metric_axes
from lib.settings import noise_level

my_rng = PCG64(14617437968570037101461646485490264188456279360134175)

@dataclass()
class ferret_to_plot():
   
    num : int
    name : str

    def load_bootstrap_results(self, file_path : str) -> None:
        """ Load results from bootstrapping """
        file_path = Path(file_path)
        self.bootstrap_BY_SNR = pd.read_csv( file_path / f"F{self.num}_BY_SNR.csv")
        self.bootstrap_over_SNR = pd.read_csv( file_path / f"F{self.num}_OVER_SNR.csv")


    def get_effect_of_cooling(self) -> None:
        """Get performance change (raw and normalized) resulting from separation of speakers"""

        # Filter for cooling and then pivot to make the calculation easy to read        
        df = self.bootstrap_over_SNR.pivot_table(index=['iteration','Mask'], columns=['treatment'], values='pCorrect')

        # Calculate the absolute difference between separated and colocated speakers, and then express relative to the max difference (i.e. that observed between clean and colocated noise)
        df['effect'] = df[True] - df[False]
        
        # Assign to object as dataframe with release from masking on each iteration (for scatter plotting)
        self.effect_of_cooling = df.reset_index(level=['Mask','iteration'])


    def report_zscore(self) -> None:

        for mask, m_data in self.effect_of_cooling.groupby('Mask'):

            bootstrap_z = m_data['effect'].mean() / m_data['effect'].std()
            print(f"F{self.num}, {mask}: z = {bootstrap_z}")


    def create_figure(self) -> None:
        """ Creates figure and axes for plotting """

        # Create plotting objects
        self.fig, axs = plt.subplots(nrows=2, ncols=2, figsize=(4,3))

        # Create a nested dictionary of metric axes 
        self.axs = dict(     
            Clean = dict(
                by_SNR = metric_axes(axs[1,0], [1.5, 1.4, 1.9, 1.9], self.num),
                over_SNR = metric_axes(axs[1,1], [6.0, 1.4, 1, 1.9], self.num)
            ),
            Restricted = dict(
                by_SNR = metric_axes(axs[0,0], [1.5, 4.4, 1.9, 1.9], self.num),
                over_SNR = metric_axes(axs[0,1], [6.0, 4.4, 1, 1.9], self.num)
            )                                                    
        )

        # Set y-axis properties here (as will be the same for all plots)
        for plot_dict in self.axs.values():
            for obj in plot_dict.values():
                obj.ygrid(ymin=0, ymax=100, major_interval=50, minor_interval=10, decimals=False, apply_limits=True)

                obj.ax.grid(True, **{'color':'.6', 'alpha':0.5})

                for axis in ['top','bottom','left','right']:
                    obj.ax.spines[axis].set_linewidth(0.75)


    def plot_over_SNR(self, mask: str, colors: dict) -> None:
        """ Plot performance for cooled and control conditions as mean and standard deviation, with distribution behind """
        
        # Filter for mask
        df = self.effect_of_cooling.copy()
        df = df[df['Mask'] == mask]
        
        if df.shape[0] == 0:                                    # Escape for Mimi during clean testing (ferret not tested)
            return None

        # Set axes properties
        ax = self.axs[mask]['over_SNR'].ax         
        xlims = (0.15, 2.85)

        ax.set_xlim(xlims)
        ax.plot( xlims, [50, 50], c = '.5', lw = 0.5, ls = '--')      # Chance level

        ax.set_xticks([1,2])
        ax.set_xticklabels(['Control','Test'], rotation=45)

        plot_bootstrap_scatter(ax, 1, df[False], colors['Control'])
        plot_bootstrap_scatter(ax, 2, df[True], colors['Bilateral'])

        print(f"F{self.num}: mean change = {df['effect'].mean():.3f}")      # Report mean change to console


    def plot_by_SNR(self, mask: str, xvar: str, xlabel: str, xlims: tuple, colors: dict) -> None:

        # Filter for mask
        df = self.bootstrap_BY_SNR.copy()
        df = df[df['Mask'] == mask]

        if df.shape[0] == 0:                                    # Escape for Mimi during clean testing (ferret not tested)
            return None

        # Average across iterations
        pt = df.pivot_table(index=['iteration'], columns=['treatment','SNR'], values='pCorrect')
        pt = pt.mean().reset_index(['treatment','SNR'])
        
        pt['mean'] = pt[0]
        pt['vowel_level'] = noise_level + pt['SNR']
        pt['treatment'] = pt['treatment'].replace({False: 'Control', True: 'Bilateral'})

        # Format axes
        self.axs[mask]['by_SNR'].xlabel(xlabel)                 # Use metric axis function for formatted x label
        
        ax = self.axs[mask]['by_SNR'].ax       
        xticks = [x for x in range(xlims[0], xlims[1]) if x % 10 == 0]

        ax.set_xlim(xlims)
        ax.set_xticks(xticks)

        z_ord = 2
        ax.plot( xlims, [50, 50], c = '.5', lw = 0.5, ls = '--', zorder=z_ord)

        # Plot data
        for treatment, t_data in pt.groupby(by='treatment'):
            
            x = t_data[xvar].to_numpy()
            y1 = t_data['mean'].to_numpy()
            c = colors[treatment]
                
            z_ord -= 1
            ax.plot( x, y1, c=c, ls='-',lw=0.6, marker='.',markersize=1, zorder=z_ord)    # Plot top line
                                                    

    def save_figure(self, file_path: str) -> None:
        """ Save to disk """
        
        plt.savefig( (Path(file_path) / f"F{self.num}.png"), dpi=300)
        plt.close()


def plot_bootstrap_scatter(ax, x: int, y: pd.Series, c: str) -> None:

        # Plot mean and standard devication of series
        y = y.to_numpy()                      
        
        ax.plot(x, np.mean(y), '.k', markersize=1, zorder=3)
        ax.plot([x, x], ([-np.std(y), np.std(y)] + np.mean(y)), linewidth=0.75, color='k', zorder=3)
        
        # Plot bootstrap iterations with jitter
        jitter = np.random.default_rng(seed=my_rng).normal(0, 0.15, len(y))                    
        x += jitter

        ax.scatter(x, y, c=c, s=1/2, marker='o', alpha=0.1, edgecolors='none', zorder=2) 


def main():
    
    # Define ferrets
    ferrets = [ferret_to_plot(1311, 'Magnum'), ferret_to_plot(1509, 'Robin'), ferret_to_plot(1706, 'Mimi')]

    # Load bootstrap results
    [x.load_bootstrap_results('Results/Vowels_Cooling/data/bootstrap') for x in ferrets]

    # Get effect of cooling for each bootstrap iteration
    [x.get_effect_of_cooling() for x in ferrets]
    
    [x.report_zscore() for x in ferrets]

    # Plot data as separate figure for each ferret
    for f in ferrets:

        f.create_figure()

        f.plot_over_SNR(mask='Restricted', colors=colors['Restricted'])
        f.plot_over_SNR(mask='Clean', colors=colors['Clean'])

        f.plot_by_SNR(mask='Restricted', xvar='SNR', xlabel='SNR (dB)', xlims= (-29, 9), colors=colors['Restricted'])
        f.plot_by_SNR(mask='Clean', xvar='vowel_level', xlabel='Level (dB SPL)', xlims= (41, 79), colors=colors['Clean'])

        f.save_figure('Results/Vowels_Cooling/images/')       

    
if __name__ == '__main__':
    main()